%let path=/folders/myfolders/sasuser.v94/ecprg193; 
libname orion "&path";


***** SAS Programming 1 Essentials - Lesson 10 combining datasets and joins;
    
***** Merge match on table looking for non matches on other table, similar to right join in SQL
title '10.6 using in= to specify join type';
proc sort data=orion.product_list
          out=work.product;
   by Supplier_ID;
run;
* SAS merge like SQL right join keeping only records that have missing supplier_id on second table;
data work.prodsup;
    merge work.product (in=pro) 
    orion.supplier (in=sup);
    by Supplier_ID;
    ** inner join, using explicit =1 syntax;
    * if pro=1 and sup=1;
    ** right join where only records missing from supplier id from supplier are returned;
    if pro and not sup;
    ** no if statement for outter join of all data
run;
proc print data=work.prodsup;
    var product_id product_name supplier_id supplier_name;
run;
title

***** Many to one merge, with sort on ome table and some reporting formatting;
    title '10.5 level 2 practice';
    proc sort data=orion.product_list out=work.product_list_sort;
        by product_level;
    run;
    proc contents data=orion.product_level;
    run;
    proc contents data=work.product_list_sort;
    run;
    
    data work.list_level;
        merge work.product_list_sort orion.product_level;
        by product_level;
        keep product_level product_level_name product_id product_name;
    run;
    
    proc print data=work.list_level noobs;
        var product_level product_level_name product_id product_name;
        where product_level = 3 & product_id;
    run;
    title;


***** One-to-many Match Merge with interesting sort and print where clause for fourth q of 2011;
    title '10.5 merge many to one practice';
    
    proc sort data=orion.orders out=work.orders_sorted;
        by Order_ID;
    run;
    * should sort orion.order_time, but it is apparently naturally generated by Order_ID.
    In practce I would sort it, but here its an interesting artifact of chronological generation naturally 
    sorting on Order_ID;
    
    data work.allorders;
        merge work.orders_sorted orion.order_item;
        by Order_ID;
        keep Order_ID Order_Item_Num Order_Type Order_Date Quantity Total_Retail_Price;
    run;
    proc print data=work.allorders;
        where (order_date and qtr(order_date)=4 and year(order_date)=2011);
    run;
    proc contents data=orion.orders;
    run;
    proc contents data=orion.order_item;
    run;
    title;
    
    
***** One-to-many Match Merge;
    title1 '10.4 One to many match merge';
    * Create Data;
    data empsau;
       input First $ Gender $ EmpID;
       datalines;
    Togar   M   121150
    Kylie   F   121151
    Birin   M   121152
    ;
    
    data phones;
       input EmpID Type $ Phone $15.;
       datalines;
        121150 Home +61(2)5555-1793
        121150 Work +61(2)5555-1794
        121151 Home +61(2)5555-1849
        121152 Work +61(2)5555-1850
        121152 Home +61(2)5555-1665
        121152 Cell +61(2)5555-1666
        ;
    * by keyword groups data in this merge;
    data empphones;
       merge empsau phones ;
       by EmpID;
    run;
    
    proc print data=empphones;
    run;
    title;


***** Match Merging datasets using key varible employee_id and some formatting of print;
    title1 '10.3 merge data';
    proc sort data=orion.employee_payroll
              out=work.payroll;
       by Employee_ID;
    run;
    proc sort data=orion.employee_addresses
              out=work.addresses;
       by Employee_ID;
    run;
    data work.payadd;
        merge work.payroll work.addresses;
        by Employee_ID;
    run;
    proc print data=work.payadd;
        var employee_id employee_name birth_date salary;
        format birth_date weekdate. salary dollar12.2;
    run;
    title;

    
***** Match Merging datasets using key varible employee_id;
    title1 '10.2 merge data sets';
    
    * Sort the datasets req for using by keyword;
    proc sort data=orion.employee_payroll
              out=work.payroll; 
       by Employee_ID;
    run;
    proc sort data=orion.employee_addresses
              out=work.addresses;
       by Employee_ID;
    run;
    * Merge the sorted datasets out to work.payadd;
    data work.payadd;
       merge work.payroll work.addresses;
       by Employee_ID;
    run;
    * Print payadd with some formatting;
    proc print data=work.payadd;
       var Employee_ID Employee_Name
           Birth_Date Salary;
       format Birth_Date weekdate.;
    run;
    title;
    
    
***** Concatonating datasets renaming similar variables to match;
    data work.allemployees;
        set 
        orion.sales 
        orion.nonsales (rename=(First=First_Name last=Last_Name));
        keep Employee_ID First_Name Last_Name Job_Title Salary;
    run;
    title1 '10.1 Concatonating reports renaming similar variables to match';
    proc print data=work.allemployees;
    run;
    title;


***** Using proc contents to determine variables in each dataset;
    title1 '10.1 Showing data set contents for orion.sales';
    proc contents data=orion.sales;
    run;
    title;
    
    title1 '10.1 Showing data set contents for orion.nonsales';
    proc contents data=orion.nonsales;
    run;
    title;


***** Concatonating three datasets with same variables;
    title1 '10.1 Concatonating three reports with same variables';
    data third_quarter;
        set orion.mnth7_2011 orion.mnth8_2011 orion.mnth9_2011;
    run;

    
